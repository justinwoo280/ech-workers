#include "CoreProcess.h"
#include <QCoreApplication>
#include <QDir>
#include <QDebug>

CoreProcess::CoreProcess(QObject *parent)
    : QObject(parent)
{
    coreExecutable = findCoreExecutable();
}

CoreProcess::~CoreProcess()
{
    stop();
}

QString CoreProcess::findCoreExecutable()
{
    QString appDir = QCoreApplication::applicationDirPath();
    QString path = appDir + "/ech-workers-core.exe";
    
    if (QFile::exists(path)) {
        return path;
    }
    
    path = appDir + "/../ech-workers-core.exe";
    if (QFile::exists(path)) {
        return QDir(path).absolutePath();
    }
    
    return "ech-workers-core.exe";
}

bool CoreProcess::start(const EWPNode &node, bool tunMode)
{
    if (isRunning()) {
        lastError = "进程已在运行";
        return false;
    }
    
    if (!QFile::exists(coreExecutable)) {
        lastError = "找不到核心文件: " + coreExecutable;
        emit errorOccurred(lastError);
        return false;
    }
    
    if (!node.isValid()) {
        lastError = "节点配置无效";
        emit errorOccurred(lastError);
        return false;
    }
    
    QStringList args = buildArguments(node, tunMode);
    
    process = new QProcess(this);
    
    connect(process, &QProcess::started, this, &CoreProcess::onProcessStarted);
    connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
            this, &CoreProcess::onProcessFinished);
    connect(process, &QProcess::errorOccurred, this, &CoreProcess::onProcessError);
    connect(process, &QProcess::readyReadStandardOutput, 
            this, &CoreProcess::onReadyReadStandardOutput);
    connect(process, &QProcess::readyReadStandardError, 
            this, &CoreProcess::onReadyReadStandardError);
    
    qDebug() << "启动核心:" << coreExecutable << args;
    
    process->start(coreExecutable, args);
    
    if (!process->waitForStarted(5000)) {
        lastError = "启动超时";
        emit errorOccurred(lastError);
        delete process;
        process = nullptr;
        return false;
    }
    
    return true;
}

void CoreProcess::stop()
{
    if (!isRunning()) return;
    
    process->terminate();
    if (!process->waitForFinished(5000)) {
        process->kill();
        process->waitForFinished(2000);
    }
    
    delete process;
    process = nullptr;
}

bool CoreProcess::isRunning() const
{
    return process && process->state() == QProcess::Running;
}

QStringList CoreProcess::buildArguments(const EWPNode &node, bool tunMode)
{
    QStringList args;
    
    // 监听地址
    args << "-l" << listenAddr;
    
    // 服务器地址 (包含路径)
    QString serverUrl;
    switch (node.transportMode) {
        case EWPNode::WS:
            serverUrl = QString("wss://%1:%2%3")
                .arg(node.serverAddress)
                .arg(node.serverPort)
                .arg(node.wsPath);
            args << "-mode" << "ws";
            break;
        case EWPNode::GRPC:
            serverUrl = QString("grpcs://%1:%2/%3")
                .arg(node.serverAddress)
                .arg(node.serverPort)
                .arg(node.grpcServiceName);
            args << "-mode" << "grpc";
            break;
        case EWPNode::XHTTP:
            serverUrl = QString("https://%1:%2%3")
                .arg(node.serverAddress)
                .arg(node.serverPort)
                .arg(node.xhttpPath);
            args << "-mode" << "xhttp";
            args << "-xhttp-mode" << node.xhttpMode;
            break;
    }
    
    args << "-f" << serverUrl;
    args << "-token" << node.uuid;
    
    // 优选 IP
    if (!node.serverIP.isEmpty()) {
        args << "-ip" << node.serverIP;
    }
    
    // ECH 配置
    if (!node.enableECH) {
        args << "-fallback";
    } else {
        if (!node.echDomain.isEmpty()) {
            args << "-ech" << node.echDomain;
        }
        if (!node.dnsServer.isEmpty()) {
            args << "-dns" << node.dnsServer;
        }
    }
    
    // 高级配置
    if (!node.enableFlow) {
        args << "-flow=false";
    }
    if (node.enablePQC) {
        args << "-pqc";
    }
    
    // TUN 模式
    if (tunMode) {
        args << "-tun";
    }
    
    return args;
}

void CoreProcess::onProcessStarted()
{
    emit started();
}

void CoreProcess::onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    Q_UNUSED(exitCode)
    
    if (exitStatus == QProcess::CrashExit) {
        emit errorOccurred("核心进程崩溃");
    }
    
    emit stopped();
}

void CoreProcess::onProcessError(QProcess::ProcessError error)
{
    QString errorMsg;
    
    switch (error) {
        case QProcess::FailedToStart:
            errorMsg = "进程启动失败";
            break;
        case QProcess::Crashed:
            errorMsg = "进程崩溃";
            break;
        case QProcess::Timedout:
            errorMsg = "进程超时";
            break;
        default:
            errorMsg = "未知错误";
            break;
    }
    
    emit errorOccurred(errorMsg);
}

void CoreProcess::onReadyReadStandardOutput()
{
    if (!process) return;
    
    QByteArray data = process->readAllStandardOutput();
    QString text = QString::fromUtf8(data).trimmed();
    
    if (!text.isEmpty()) {
        for (const auto &line : text.split('\n')) {
            emit logReceived(line.trimmed());
        }
    }
}

void CoreProcess::onReadyReadStandardError()
{
    if (!process) return;
    
    QByteArray data = process->readAllStandardError();
    QString text = QString::fromUtf8(data).trimmed();
    
    if (!text.isEmpty()) {
        for (const auto &line : text.split('\n')) {
            emit logReceived("[ERR] " + line.trimmed());
        }
    }
}
